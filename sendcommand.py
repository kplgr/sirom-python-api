import argparse
import enum
import siromlib
import canlib



def main():

    parser = argparse.ArgumentParser(
        description='Send commands to a SIROM device via CAN bus',
        epilog='If (when) nothing works, check that the can network adapter is correctly set up',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('-v', '--verbose', help='Enable verbose output', action='store_true')
    parser.add_argument('-i', '--interface', help='CAN interface', type=str, default='can0')
    parser.add_argument('-d', '--device', help='SIROM device ID', type=int, default=0x01)
    parser.add_argument('-s', '--speed', help='SIROM motor speed [0-255]', type=int, default=50)
    parser.add_argument('-p', '--power', dest='powerConfigOption', help='SIROM power setting', type=siromlib.SiromPowerConfig, action=EnumAction, default=siromlib.SiromPowerConfig.POWERCFG_F2R)
    parser.add_argument('command', help='Command to send to sirom', type=siromlib.SiromCommandType, action=EnumAction) 
    

    args = parser.parse_args()

    if args.verbose:
        print(args)

    print(f'Checking interface {args.interface} confuguration... ', end='')    
    bus = canlib.LinuxCanBusTransport(args.interface)

    print('OK.')


    command = siromlib.SiromCommand(
        commandType = args.command, 
        motorSpeed = siromlib.SiromMotorSpeed(args.speed),
        powerConfig = args.powerConfigOption
    )


    print(f'Sending command {command.type.name} to SIROM {args.device} over {args.interface}... ', end='')
    bus.sendCommand(canbusTargetIdentifer=args.device, command=command, verbose=args.verbose)

    print('Done! \n')








class EnumAction(argparse.Action):
    def __init__(self, **kwargs):
        # Pop off the type value
        enum_type = kwargs.pop("type", None)

        # Ensure an Enum subclass is provided
        if enum_type is None:
            raise ValueError(
                "type must be assigned an Enum when using EnumAction")
        if not issubclass(enum_type, enum.Enum):
            raise TypeError("type must be an Enum when using EnumAction")

        # Generate choices from the Enum
        kwargs.setdefault("choices", tuple(e.name for e in enum_type))

        super(EnumAction, self).__init__(**kwargs)

        self._enum = enum_type

    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 value,
                 option_string: str = None):
        # Convert value back into an Enum
        if isinstance(value, str):
            value = self._enum[value]
            setattr(namespace, self.dest, value)
        elif value is None:
            raise argparse.ArgumentTypeError(
                f"You need to pass a value after {option_string}!")
        else:
            # A pretty invalid choice message will be generated by argparse
            raise argparse.ArgumentTypeError()



if __name__ == '__main__':
    main()